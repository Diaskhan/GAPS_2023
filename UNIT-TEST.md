
# Unit-тесты — это первый этап при выявлении багов в приложении, за ними идут более «тонкие» тесты:
- интеграционные;
- приемочные;
- тесты «руками».

что такое хороший юнит тест <br>

# Ваши тесты так же важны, 
как и сама реализация. Все, что на самом деле имеет значение, это то, отвечает ли код требованиям. В противном случае не важно, как именно он реализован.
Юнит-тесты сочетают в себе множество функций, которые делают их секретным оружием для достижения успеха в разработке приложения:

- Помощь в разработке: первоочередное написание тестов дает более четкое представление об идеальном дизайне API.
- Документация фич (для девелоперов): описания тестов или «test descriptions» закрепляют в коде каждое реализованное функциональное требование.
- Проверка понимания процесса разработки: понимает ли разработчик проблему достаточно хорошо, чтобы четко выразить в коде все критические требования к компонентам?
- Обеспечение качества: ручной QA подразумевает ошибки! По своему опыту автор говорит о том, что разработчик не может запомнить все функции, которые необходимо протестировать после внесения изменений в рефакторинг, добавления или удаления фич.
- Помощь при сontinuous delivery: автоматизированный QA позволяет автоматически предотвращать деплой поврежденных билдов в продакшн.


# AAA (Arrange, Act, Assert) паттерн

Если посмотреть на юнит тест, то для большинства можно четко выделить 3 части кода:

- Arrange (настройка) — в этом блоке кода мы настраиваем тестовое окружение тестируемого юнита;
- Act — выполнение или вызов тестируемого сценария;
- Assert — проверка того, что тестируемый вызов ведет себя определенным образом.

Этот паттерн улучшает структуру кода и его читабельность, однако начинать писать тест нужно всегда с элемента Act.


# Принципы F.I.R.S.T. и почему их нужно соблюдать
Роберт Мартин в своей книге "Чистый Код" описал 5 простых принципов которым должны соответствовать юнит тесты. Вкратце принципы звучат так:
- Fast - тесты должны быть невероятно быстрыми, чтобы их хотелось запускать как можно чаще
- Independent - тесты не должны зависеть от результатов выполнения других тестов
- Repeatable - тесты должны всегда выдавать одинаковый результат в любом окружении
- Self-Validating - результат выполнения тестов бинарен и полностью автоматизирован. Разработчик должен видеть явный ответ тесты прошли или нет.
- Timely - тест должен быть написан вовремя, то есть прямо перед кодом который позволит тесту пройти успешно.


# TDD, test-driven development 
или процесс разработки через тестирование — это методология разработки программного обеспечения, которая основывается на повторении коротких циклов разработки: изначально пишется тест, покрывающий желаемое изменение, затем пишется программный код, который реализует желаемое поведение системы и позволит пройти написанный тест, а затем проводится рефакторинг написанного кода с постоянной проверкой прохождения всех тестов.

Цикл разработки по TDD
- Добавить тест для новой (еще не реализованной) функциональности или для воспроизведения существующего бага
- Запустить все тесты и убедиться, что новый тест не проходит
- Написать код, который обеспечит прохождение теста: 
- Запустить тесты и убедиться, что они все прошли успешно: прохождение нового теста подтверждает реализацию нового функционала или исправление существующей ошибки, а прохождение остальных позволяет удостовериться, что ранее реализованный функционал работает по-прежнему корректно. 
- Заняться рефакторингом и оптимизацией — улучшение сопровождаемости и быстродействия целесообразно осуществлять уже после того, как получилось добиться проверяемой работоспособности
- Перезапустить тесты и убедиться, что они все ещё проходят успешно
- Повторить цикл

<hr>


# Виды тестирования
1. Модульные тесты
Модульные тесты работают на очень низком уровне, близко к исходному коду приложения. Они заключаются в тестировании отдельных методов и функций классов, компонентов или модулей, используемых в ПО. Модульные тесты, как правило, не требуют больших расходов на автоматизацию и могут выполняться сервером непрерывной интеграции очень быстро.

2. Интеграционные тесты
В ходе интеграционного тестирования проверяется, хорошо ли работают вместе различные модули и сервисы, используемые приложением. Например, можно протестировать взаимодействие с базой данных или убедиться, что микросервисы работают вместе так, как задумано. Этот вид тестирования является более затратным, поскольку для проведения тестов требуется запуск различных компонентов приложения.

3. Функциональные тесты
В функциональных тестах основное внимание уделяется бизнес-требованиям к приложению. Они проверяют только результат некоторого действия и не проверяют промежуточные состояния системы при выполнении этого действия.
Иногда возникает путаница между понятиями интеграционных и функциональных тестов, так как и те и другие требуют взаимодействия нескольких компонентов друг с другом. Разница в том, что интеграционный тест нужен просто чтобы убедиться, что вы можете отправлять запросы к базе данных, тогда как функциональный тест будет ожидать получения из базы данных определенного значения в соответствии с требованиями продукта.

4. Сквозные тесты
Сквозное тестирование копирует поведение пользователя при работе с ПО в контексте всего приложения. Оно обеспечивает контроль того, что различные схемы действий пользователя работают должным образом. Сценарии могут быть как очень простыми (загрузка веб-страницы или вход в систему), так и гораздо более сложными (проверка почтовых уведомлений, онлайн-платежей и т. д.).
Сквозные тесты очень полезны, но их выполнение обходится довольно дорого, к тому же, когда они автоматизированы, такие тесты тяжело обслуживать. Рекомендуется иметь в наличии несколько основных сквозных тестов и активнее полагаться на более низкие уровни тестирования (модульные и интеграционные тесты), чтобы получать возможность быстро выявлять критические изменения.

5. Приемочное тестирование
Приемочные тесты — это формальные тесты, которые проверяют, отвечает ли система требованиям бизнеса. При этом во время тестирования должно быть запущено само приложение, и основное внимание уделяется воспроизведению поведения пользователей. В ходе этого тестирования возможен даже замер производительности системы, и в случае несоответствия установленным требованиям внесенные изменения могут быть отклонены.

6. Тестирование производительности
В тестах производительности оценивается работа системы при определенной рабочей нагрузке. С помощью таких тестов можно оценить надежность, скорость, масштабируемость и отзывчивость приложения. Например, это может быть наблюдение за временем отклика при выполнении большого количества запросов или определение поведения системы при работе со значительными объемами данных. Этот вид тестирования позволяет определить, соответствует ли приложение требованиям к производительности, найти узкие места, оценить стабильность при пиковом трафике и многое другое.

7. Smoke-тестирование
Smoke-тесты — это базовые тесты, которые проверяют основные функциональные возможности приложения. Они должны выполняться быстро, поскольку цель таких тестов — убедиться, что основные возможности системы работают как запланировано.
Smoke-тесты полезно запускать сразу после создания новой сборки (для определения, можно ли запускать более ресурсоемкие тесты) или сразу после развертывания (чтобы убедиться, что приложение работает правильно в новой, только что развернутой среде).
