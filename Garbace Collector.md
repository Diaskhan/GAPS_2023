1.Что происходит с мелкими предметами?
Небольшие объекты .NET размещаются в кучах малых объектов (SOH). Их три: поколение 0, поколение 1 и поколение 2. Объекты перемещаются вверх по этим поколениям в зависимости от их возраста.

Новые объекты помещаются в поколение 0. Когда поколение 0 заполняется, запускается сборщик мусора .NET (GC), удаляющий объекты, которые больше не нужны, и перемещая все остальное в поколение 1. Если поколение 1 заполняется, сборщик мусора запускается снова. , но также перемещает объекты из поколения 1 в поколение 2.

Полный запуск GC происходит, когда поколение 2 становится полным. Это очищает ненужные объекты Gen 2, перемещает объекты Gen 1 в Gen 2, затем перемещает объекты Gen 0 в Gen 1 и, наконец, очищает все, на что нет ссылок. После каждого запуска GC затронутые кучи уплотняются, чтобы память, которая все еще используется, оставалась вместе.

Этот подход поколений обеспечивает эффективную работу — трудоемкий процесс уплотнения выполняется только в случае крайней необходимости.

Примечание. Если вы видите большую долю памяти в Gen 2, это показатель того, что память удерживается в течение длительного времени и что у вас могут быть проблемы с памятью. Здесь может пригодиться инструмент профилирования памяти, такой как ANTS Memory Profiler .
<hr>
2.Что происходит с более крупными объектами?
Объекты размером более 85 КБ размещаются в куче больших объектов (LOH). Они не уплотняются из-за накладных расходов на копирование больших кусков памяти. Когда происходит полная сборка мусора, диапазоны адресов неиспользуемых объектов LOH вместо этого записываются в таблицу распределения свободного пространства.

Когда выделяется новый объект, эта таблица свободного пространства проверяется на наличие диапазона адресов, достаточно большого для размещения объекта. Если он существует, объект размещается там, если нет, он размещается на следующем свободном месте.

Поскольку объекты вряд ли будут иметь точный размер пустого диапазона адресов, между объектами почти всегда остаются небольшие участки памяти, что приводит к фрагментации. Если эти фрагменты меньше 85 КБ, повторное использование вообще невозможно. Следовательно, по мере увеличения потребности в выделении новые сегменты резервируются, даже если фрагментированное пространство все еще доступно.

Кроме того, когда необходимо выделить большой объект, .NET в любом случае стремится добавить объект в конец, а не запускать дорогостоящий сборщик мусора Gen 2 GC. Это хорошо для производительности, но является серьезной причиной фрагментации памяти.
<hr>

3.Сборщик мусора можно запускать в разных режимах для оптимизации производительности.
.NET решает проблему компромисса между производительностью и эффективностью кучи, предоставляя несколько режимов для сборщика мусора.

Режим рабочей станции дает максимальную отзывчивость пользователю и сокращает паузы из-за GC. Он может работать как «параллельный» или «непараллельный», в зависимости от потока, в котором работает сборщик мусора. По умолчанию используется concurrent, при котором для сборщика мусора используется отдельный поток, поэтому приложение может продолжать выполнение во время выполнения сборщика мусора.

Режим сервера обеспечивает максимальную пропускную способность, масштабируемость и производительность для серверных сред. Размеры сегментов и пороговые значения генерации обычно намного больше в режиме сервера, чем в режиме рабочей станции, что отражает более высокие требования, предъявляемые к серверам.

В режиме сервера сборка мусора выполняется параллельно в нескольких потоках, выделяя отдельные SOH и LOH каждому логическому процессору, чтобы потоки не мешали друг другу.

Платформа .NET предоставляет механизм перекрестных ссылок, поэтому объекты могут по-прежнему ссылаться друг на друга в кучах. Однако, поскольку скорость отклика приложений не является прямой целью режима сервера, все потоки приложений приостанавливаются на время GC.
<hr>

4.Слабые ссылки предлагают компромисс между производительностью и эффективностью использования памяти.
Слабый объект ссылается на альтернативный источник корней GC, позволяя вам удерживать объекты, позволяя при этом собирать их, если это необходимо GC. Это компромисс между производительностью кода и эффективностью использования памяти; создание объекта занимает процессорное время, но его загрузка требует памяти.

Слабые ссылки особенно подходят для больших структур данных. Например, представьте, что у вас есть приложение, которое позволяет пользователям просматривать большие структуры данных, к некоторым из которых они могут вернуться. Вы можете преобразовать любые сильные ссылки на структуры, которые они просматривали, в слабые ссылки. Если пользователи вернутся к этим структурам, они будут доступны, но если нет, GC может восстановить память, если это необходимо.
<hr>

5.Закрепление объекта может создавать ссылки для перехода между управляемым и неуправляемым кодом.
.NET использует структуру под названием GCHandle для отслеживания объектов кучи. GCHandle можно использовать для передачи ссылок на объекты между управляемыми и неуправляемыми доменами, и для этого .NET поддерживает таблицу GCHandles. Существует четыре типа GCHandle, включая Pinned, который используется для фиксации объекта по определенному адресу в памяти.

Основная проблема с закреплением объектов заключается в том, что это может привести к фрагментации SOH. Если объект закреплен во время GC, то по определению его нельзя переместить. В зависимости от того, как вы используете закрепление, оно может снизить эффективность сжатия, оставляя пробелы в куче. Лучший способ избежать этого — закрепить на очень короткое время, а затем отпустить.