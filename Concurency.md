

# мютекс
Только один поток может получить блокировку и иметь доступ к защищаемым мьютексом синхронизированным областям кода.
```C#
            SharedRes.mtx.WaitOne();
            //somecode
            SharedRes.mtx.ReleaseMutex();
```

# семафор
Обычно поток, которому требуется доступ к общему ресурсу, пытается получить разрешение от семафора. Если значение счетчика семафора больше нуля, то поток получает разрешение, а счетчик семафора декрементируется. В противном случае поток блокируется до тех пор, пока не получит разрешение. Когда же потоку больше не требуется доступ к общему ресурсу, он высвобождает разрешение, а счетчик семафора инкрементируется. Если разрешения ожидает другой поток, то он получает его в этот момент. Количество одновременно разрешаемых доступов указывается при создании семафора. Так, если создать семафор, одновременно разрешающий только один доступ, то такой семафор будет действовать как мьютекс.

# lock

Решение проблемы состоит в том, чтобы синхронизировать потоки и ограничить доступ к разделяемым ресурсам на время их использования каким-нибудь потоком. Для этого используется ключевое слово lock. Оператор lock определяет блок кода, внутри которого весь код блокируется и становится недоступным для других потоков до завершения работы текущего потока. Остальный потоки помещаются в очередь ожидания и ждут, пока текущий поток не освободит данный блок кода. В итоге с помощью lock мы можем переделать предыдущий пример следующим образом:

```C#
int x = 0;
object locker = new();  // объект-заглушка
// запускаем пять потоков
for (int i = 1; i < 6; i++)
{
    Thread myThread = new(Print);
    myThread.Name = $"Поток {i}";
    myThread.Start();
}
 
 
void Print()
{
    lock (locker)
    {
        x = 1;
        for (int i = 1; i < 6; i++)
        {
            Console.WriteLine($"{Thread.CurrentThread.Name}: {x}");
            x++;
            Thread.Sleep(100);
        }
    }
}
```

# Структура SpinLock
В .NET 4 появилась структура SpinLock. Она может применяться в случае, когда накладные расходы, связанные с объектами блокировки (Monitor), оказываются слишком высокими из-за сборки мусора. Эта структура особенно полезна при большом количестве блокировок (например, для каждого узла в списке) и чрезмерно коротких периодах их удержания. Следует стараться избегать использования более чем одной структуры SpinLock и не вызывать ничего, что может приводить к блокировке.

За исключением различий в архитектуре, структура SpinLock в плане применения очень похожа на класс Monitor. Получение блокировки осуществляется с помощью методов Enter() или TryEnter(), а снятие — с помощью метода Exit(). Кроме того, SpinLock предлагает свойства для предоставления информации в случае, если в текущий момент находится в заблокированном состоянии: IsHeld и IsHeldByCurrentThread.

При передаче экземпляров SpinLock следует соблюдать осторожность. Из-за того, что SpinLock определена как struct, ее присваивание приводит к созданию копии. Поэтому экземпляры SpinLock должны всегда передаваться по ссылке.

# Таким образом, мьютекс и спин-блокировка — это 
два метода синхронизации процессов или потоков. Ключевое различие между мьютексом и спин-блокировкой заключается в том, что спин-блокировка требует, чтобы поток, пытающийся получить блокировку, ждал в цикле и периодически проверял ее доступность. Напротив, мьютекс позволяет нескольким процессам поочередно совместно использовать ресурс. И спин-блокировка, и мьютекс являются методами блокировки, но работа этих методов различна.

По поводу переиспользования потоков уже подсказали в комментах, для этого существует ThreadPool.

По поводу примитивов синхронизации. Windows имеет 4 примитива для синхронизации потоков:

- Event. В .NET есть обертка в виде классов AutoResetEvent/ManualResetEvent. Нечто подобное можно сделать при помощи Monitor.Pulse() и Monitor.Wait(). Но объекты Windows более функциональные.
- Mutex. С одноименным классом-оберткой. Подобный функционал есть и в самом .NET, в методах класса Monitor или в операторе C# lock.
- Semaphore. С одноименным классом-оберткой.
- Waitable timer. В NET нет обертки для этого объекта, но зато есть другие таймеры.

Кроме этого потоки можно синхронизировать по другим объектам, например потокам или процессам. Если вы в коде вызываете thread.Join(), вы синхронизируете один поток с окончанием работы другого.


.NET: Инструменты для работы с многопоточностью и асинхронностью. Часть 1
https://habr.com/en/post/452094/

.NET: Инструменты для работы с многопоточностью и асинхронностью. Часть 2
https://habr.com/en/post/459514/

