Принципы SOLID в картинках
==========================

Reading time 4 min

Views 225K

[Productivity Inside corporate blog](/en/company/productivity_inside/blog/) [Perfect code \*](/en/hub/complete_code/)

Translation

[Original author: Ugonna Thelma](https://medium.com/backticks-tildes/the-s-o-l-i-d-principles-in-pictures-b34ce2f1e898)

![](https://habrastorage.org/r/w1560/webt/ky/jk/lc/kyjklcgdkx2rxgcbrfxbnnofjqu.png)  
  
Если вы знакомы с [объектно-ориентированным программированием](https://ru.wikipedia.org/wiki/%D0%9E%D0%B1%D1%8A%D0%B5%D0%BA%D1%82%D0%BD%D0%BE-%D0%BE%D1%80%D0%B8%D0%B5%D0%BD%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D0%BE%D0%B5_%D0%BF%D1%80%D0%BE%D0%B5%D0%BA%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5), то наверняка слышали и о [принципах SOLID](https://ru.wikipedia.org/wiki/SOLID_(%D0%BE%D0%B1%D1%8A%D0%B5%D0%BA%D1%82%D0%BD%D0%BE-%D0%BE%D1%80%D0%B8%D0%B5%D0%BD%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D0%BE%D0%B5_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5)). Эти пять правил разработки ПО задают траекторию, по которой нужно следовать, когда пишешь программы, чтобы их проще было масштабировать и поддерживать. Они получили известность благодаря программисту Роберту Мартину.  
  
В Сети множество отличных статей, где рассказывается о принципах SOLID, но иллюстрированных среди них мне практически не попадалось. Из-за этого таким людям со склонностью к визуальному восприятию информации – таким, как я – бывает сложно схватывать суть и не отвлекаться.  
  
Основная цель этой статьи – лучше усвоить принципы SOLID через отрисовку иллюстраций, а также определить назначение каждого принципа. Дело в том, что некоторые из принципов кажутся похожими, но функции выполняют разные. Может получиться так, что одному принципу следуешь, а другой при этом нарушаешь, хотя с виду особой разницы между ними нет.  
  
Чтобы проще читалось, я упоминаю здесь только классы, однако всё сказанное в статье применимо также к функциям, методам и модулям, так что имейте это в виду.  
  
Ну, приступим.  
  

### Принципы SOLID

  
  

#### S – Single Responsibility (Принцип единственной ответственности)

  

> _Каждый класс должен отвечать только за одну операцию._

  
![](https://habrastorage.org/r/w1560/webt/ug/2v/ts/ug2vtsbxvspdx0elsmexemp3kxm.png)  
  
Если класс отвечает за несколько операций сразу, вероятность возникновения багов возрастает – внося изменения, касающиеся одной из операций вы, сами того не подозревая, можете затронуть и другие.  
  
**Назначение**  
  
Принцип служит для разделения типов поведения, благодаря которому ошибки, вызванные модификациями в одном поведении, не распространялись на прочие, не связанные с ним типы.  
  

#### O — Open-Closed (Принцип открытости-закрытости)

  

> _Классы должны  быть  открыты для расширения, но закрыты для модификации._

  
![](https://habrastorage.org/r/w1560/webt/ir/sm/eb/irsmeboddq2dcx1eaky5qo83v64.png)  
  
Когда вы меняете текущее поведение класса, эти изменения сказываются на всех системах, работающих с данным классом. Если хотите, чтобы класс выполнял больше операций, то идеальный вариант – не заменять старые на новые, а добавлять новые к уже существующим.  
  
**Назначение**  
  
Принцип служит для того, чтобы делать поведение класса более разнообразным, не вмешиваясь в текущие операции, которые он выполняет. Благодаря этому вы избегаете ошибок в тех фрагментах кода, где задействован этот класс.  
  

#### L — Liskov Substitution (Принцип подстановки Барбары Лисков)

  

> _Если П является подтипом Т, то любые объекты типа Т, присутствующие в программе, могут заменяться объектами типа П без негативных последствий для функциональности программы._

  
![](https://habrastorage.org/r/w1560/webt/hj/dt/a-/hjdta-bs2bvk2ga_dabxajfqjnk.png)  
В случаях, когда класс-потомок не способен выполнять те же действия, что и класс-родитель, возникает риск появления ошибок.  
  
Если у вас имеется класс и вы создаете на его базе другой класс, исходный класс становится родителем, а новый – его потомком. Класс-потомок должен производить такие же операции, как и класс-родитель. Это называется наследственностью.  
  
Необходимо, чтобы класс-потомок был способен обрабатывать те же запросы, что и родитель, и выдавать тот же результат. Или же результат может отличаться, но при этом относиться к тому же типу. На картинке это показано так: класс-родитель подаёт кофе (в любых видах), значит, для класса-потомка приемлемо подавать капучино (разновидность кофе), но неприемлемо подавать воду.  
  
Если класс-потомок не удовлетворяет этим требованиям, значит, он слишком сильно отличается от родителя и нарушает принцип.  
  
**Назначение**  
  
Принцип служит для того, чтобы обеспечить постоянство: класс-родитель и класс-потомок могут использоваться одинаковым образом без нарушения работы программы.  
  

#### I — Interface Segregation (Принцип разделения интерфейсов)

  

> _Не следует ставить клиент в зависимость от методов, которые он не использует._

  
![](https://habrastorage.org/r/w1560/webt/v8/co/dn/v8codny8xpy355zcqvfro-7ep8a.png)  
  
Когда классу приходится производить действия, не несущие никакой реальной пользы, это выливается в пустую трату ресурса, а в случае, если класс выполнять эти действия не способен, ведёт к возникновению багов.  
  
Класс должен производить только те операции, которые необходимы для осуществления его функций. Все другие действия следует либо удалить совсем, либо переместить, если есть вероятность, что они понадобятся другому классу в будущем.  
  
**Назначение**  
  
Принцип служит для того, чтобы раздробить единый набор действий на ряд наборов поменьше – таким образом, каждый класс делает то, что от него действительно требуется, и ничего больше.  
  

#### D — Dependency Inversion (Принцип инверсии зависимостей)

  

> _Модули верхнего уровня не должны зависеть от модулей нижнего уровня. И те, и другие должны зависеть от абстракций. Абстракции не должны зависеть от деталей. Детали должны зависеть от абстракций._

  
![](https://habrastorage.org/r/w1560/webt/du/7r/0u/du7r0use6rfrrqr8wc9a2qcvf2y.png)  
Для начала объясню термины, которые здесь применяются, простыми словами.  
  
Модули (или классы) верхнего уровня = классы, которые выполняют операцию при помощи инструмента  
Модули (или классы) нижнего уровня = инструменты, которые нужны для выполнения операций  
Абстракции – представляют интерфейс, соединяющий два класса  
Детали = специфические характеристики работы инструмента  
  
Согласно данному принципу, класс не должен соединяться с инструментом, который применяет для выполнения операции. Вместо этого он должен быть соединён с интерфейсом, который поможет установить связь между инструментом и классом.  
  
Кроме того, принцип гласит, что ни интерфейс, ни класс, не обязаны вникать в специфику работы инструмента. Напротив, это инструмент должен подходить под требования интерфейса.  
  
**Назначение**  
  
Этот принцип служит для того, чтобы устранить зависимость классов верхнего уровня от классов нижнего уровня за счёт введения интерфейсов.  
  

#### Обобщая сказанное

  
Мы разобрали все пять принципов и сформулировали для каждого назначение. Всё это призвано помочь вам писать код, который можно модифицировать, расширять и тестировать с минимумом проблем. Спасибо, что прочитали; надеюсь, вы получили не меньше удовольствия, чем я в процессе работы над статьёй.
