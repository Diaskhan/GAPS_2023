
# отличия массива от коллекции
-----------------------
Разница есть.
Массив - структура объектов фиксированного размера
Коллекция - структура объектов с динамически изменяющейся размерностью
Отсюда определяется и область применения: массивы следует применять там, где будет строго фиксированное количество элементов; если предполагается изменение количества элементов, следует применять коллекции.


# мютекс
Только один поток может получить блокировку и иметь доступ к защищаемым мьютексом синхронизированным областям кода.
```C#
            SharedRes.mtx.WaitOne();
            //somecode
            SharedRes.mtx.ReleaseMutex();
```

# семафор
Обычно поток, которому требуется доступ к общему ресурсу, пытается получить разрешение от семафора. Если значение счетчика семафора больше нуля, то поток получает разрешение, а счетчик семафора декрементируется. В противном случае поток блокируется до тех пор, пока не получит разрешение. Когда же потоку больше не требуется доступ к общему ресурсу, он высвобождает разрешение, а счетчик семафора инкрементируется. Если разрешения ожидает другой поток, то он получает его в этот момент. Количество одновременно разрешаемых доступов указывается при создании семафора. Так, если создать семафор, одновременно разрешающий только один доступ, то такой семафор будет действовать как мьютекс.

# lock

Решение проблемы состоит в том, чтобы синхронизировать потоки и ограничить доступ к разделяемым ресурсам на время их использования каким-нибудь потоком. Для этого используется ключевое слово lock. Оператор lock определяет блок кода, внутри которого весь код блокируется и становится недоступным для других потоков до завершения работы текущего потока. Остальный потоки помещаются в очередь ожидания и ждут, пока текущий поток не освободит данный блок кода. В итоге с помощью lock мы можем переделать предыдущий пример следующим образом:

```C#
int x = 0;
object locker = new();  // объект-заглушка
// запускаем пять потоков
for (int i = 1; i < 6; i++)
{
    Thread myThread = new(Print);
    myThread.Name = $"Поток {i}";
    myThread.Start();
}
 
 
void Print()
{
    lock (locker)
    {
        x = 1;
        for (int i = 1; i < 6; i++)
        {
            Console.WriteLine($"{Thread.CurrentThread.Name}: {x}");
            x++;
            Thread.Sleep(100);
        }
    }
}
```

# Таким образом, мьютекс и спин-блокировка — это 
два метода синхронизации процессов или потоков. Ключевое различие между мьютексом и спин-блокировкой заключается в том, что спин-блокировка требует, чтобы поток, пытающийся получить блокировку, ждал в цикле и периодически проверял ее доступность. Напротив, мьютекс позволяет нескольким процессам поочередно совместно использовать ресурс. И спин-блокировка, и мьютекс являются методами блокировки, но работа этих методов различна.


спинлок выполняется быстрее
![спинлок выполняется быстрее](
https://www.codeproject.com/KB/threads/Spin_Lock/Results.jpg)


.NET: Инструменты для работы с многопоточностью и асинхронностью. Часть 1
https://habr.com/en/post/452094/

.NET: Инструменты для работы с многопоточностью и асинхронностью. Часть 2
https://habr.com/en/post/459514/


# Unit-тесты — это первый этап при выявлении багов в приложении, за ними идут более «тонкие» тесты:
- интеграционные;
- приемочные;
- тесты «руками».

что такое хороший юнит тест <br>

# Ваши тесты так же важны, 
как и сама реализация. Все, что на самом деле имеет значение, это то, отвечает ли код требованиям. В противном случае не важно, как именно он реализован.
Юнит-тесты сочетают в себе множество функций, которые делают их секретным оружием для достижения успеха в разработке приложения:

- Помощь в разработке: первоочередное написание тестов дает более четкое представление об идеальном дизайне API.
- Документация фич (для девелоперов): описания тестов или «test descriptions» закрепляют в коде каждое реализованное функциональное требование.
- Проверка понимания процесса разработки: понимает ли разработчик проблему достаточно хорошо, чтобы четко выразить в коде все критические требования к компонентам?
- Обеспечение качества: ручной QA подразумевает ошибки! По своему опыту автор говорит о том, что разработчик не может запомнить все функции, которые необходимо протестировать после внесения изменений в рефакторинг, добавления или удаления фич.
- Помощь при сontinuous delivery: автоматизированный QA позволяет автоматически предотвращать деплой поврежденных билдов в продакшн.


# AAA (Arrange, Act, Assert) паттерн

Если посмотреть на юнит тест, то для большинства можно четко выделить 3 части кода:

- Arrange (настройка) — в этом блоке кода мы настраиваем тестовое окружение тестируемого юнита;
- Act — выполнение или вызов тестируемого сценария;
- Assert — проверка того, что тестируемый вызов ведет себя определенным образом.

Этот паттерн улучшает структуру кода и его читабельность, однако начинать писать тест нужно всегда с элемента Act.


# Принципы F.I.R.S.T. и почему их нужно соблюдать
Роберт Мартин в своей книге "Чистый Код" описал 5 простых принципов которым должны соответствовать юнит тесты. Вкратце принципы звучат так:
- Fast - тесты должны быть невероятно быстрыми, чтобы их хотелось запускать как можно чаще
- Independent - тесты не должны зависеть от результатов выполнения других тестов
- Repeatable - тесты должны всегда выдавать одинаковый результат в любом окружении
- Self-Validating - результат выполнения тестов бинарен и полностью автоматизирован. Разработчик должен видеть явный ответ тесты прошли или нет.
- Timely - тест должен быть написан вовремя, то есть прямо перед кодом который позволит тесту пройти успешно.


# TDD, test-driven development 
или процесс разработки через тестирование — это методология разработки программного обеспечения, которая основывается на повторении коротких циклов разработки: изначально пишется тест, покрывающий желаемое изменение, затем пишется программный код, который реализует желаемое поведение системы и позволит пройти написанный тест, а затем проводится рефакторинг написанного кода с постоянной проверкой прохождения всех тестов.

Цикл разработки по TDD
- Добавить тест для новой (еще не реализованной) функциональности или для воспроизведения существующего бага
- Запустить все тесты и убедиться, что новый тест не проходит
- Написать код, который обеспечит прохождение теста: 
- Запустить тесты и убедиться, что они все прошли успешно: прохождение нового теста подтверждает реализацию нового функционала или исправление существующей ошибки, а прохождение остальных позволяет удостовериться, что ранее реализованный функционал работает по-прежнему корректно. 
- Заняться рефакторингом и оптимизацией — улучшение сопровождаемости и быстродействия целесообразно осуществлять уже после того, как получилось добиться проверяемой работоспособности
- Перезапустить тесты и убедиться, что они все ещё проходят успешно
- Повторить цикл

