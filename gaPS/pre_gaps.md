
# отличия массива от коллекции
-----------------------
Разница есть.
Массив - структура объектов фиксированного размера
Коллекция - структура объектов с динамически изменяющейся размерностью
Отсюда определяется и область применения: массивы следует применять там, где будет строго фиксированное количество элементов; если предполагается изменение количества элементов, следует применять коллекции.


# мютекс
Только один поток может получить блокировку и иметь доступ к защищаемым мьютексом синхронизированным областям кода.
```C#
            SharedRes.mtx.WaitOne();
            //somecode
            SharedRes.mtx.ReleaseMutex();
```

# семафор
Обычно поток, которому требуется доступ к общему ресурсу, пытается получить разрешение от семафора. Если значение счетчика семафора больше нуля, то поток получает разрешение, а счетчик семафора декрементируется. В противном случае поток блокируется до тех пор, пока не получит разрешение. Когда же потоку больше не требуется доступ к общему ресурсу, он высвобождает разрешение, а счетчик семафора инкрементируется. Если разрешения ожидает другой поток, то он получает его в этот момент. Количество одновременно разрешаемых доступов указывается при создании семафора. Так, если создать семафор, одновременно разрешающий только один доступ, то такой семафор будет действовать как мьютекс.

# lock

Решение проблемы состоит в том, чтобы синхронизировать потоки и ограничить доступ к разделяемым ресурсам на время их использования каким-нибудь потоком. Для этого используется ключевое слово lock. Оператор lock определяет блок кода, внутри которого весь код блокируется и становится недоступным для других потоков до завершения работы текущего потока. Остальный потоки помещаются в очередь ожидания и ждут, пока текущий поток не освободит данный блок кода. В итоге с помощью lock мы можем переделать предыдущий пример следующим образом:

```C#
int x = 0;
object locker = new();  // объект-заглушка
// запускаем пять потоков
for (int i = 1; i < 6; i++)
{
    Thread myThread = new(Print);
    myThread.Name = $"Поток {i}";
    myThread.Start();
}
 
 
void Print()
{
    lock (locker)
    {
        x = 1;
        for (int i = 1; i < 6; i++)
        {
            Console.WriteLine($"{Thread.CurrentThread.Name}: {x}");
            x++;
            Thread.Sleep(100);
        }
    }
}
```

synchronization primitives

Unit-тесты — это первый этап при выявлении багов в приложении, за ними идут более «тонкие» тесты:
- интеграционные;
- приемочные;
- тесты «руками».

что такое хороший юнит тест <br>


# AAA (Arrange, Act, Assert) паттерн

Если посмотреть на юнит тест, то для большинства можно четко выделить 3 части кода:

- Arrange (настройка) — в этом блоке кода мы настраиваем тестовое окружение тестируемого юнита;
- Act — выполнение или вызов тестируемого сценария;
- Assert — проверка того, что тестируемый вызов ведет себя определенным образом.

Этот паттерн улучшает структуру кода и его читабельность, однако начинать писать тест нужно всегда с элемента Act.


# Принципы F.I.R.S.T. и почему их нужно соблюдать
Роберт Мартин в своей книге "Чистый Код" описал 5 простых принципов которым должны соответствовать юнит тесты. Вкратце принципы звучат так:
- Fast - тесты должны быть невероятно быстрыми, чтобы их хотелось запускать как можно чаще
- Independent - тесты не должны зависеть от результатов выполнения других тестов
- Repeatable - тесты должны всегда выдавать одинаковый результат в любом окружении
- Self-Validating - результат выполнения тестов бинарен и полностью автоматизирован. Разработчик должен видеть явный ответ тесты прошли или нет.
- Timely - тест должен быть написан вовремя, то есть прямо перед кодом который позволит тесту пройти успешно.


# TDD, test-driven development 
или процесс разработки через тестирование — это методология разработки программного обеспечения, которая основывается на повторении коротких циклов разработки: изначально пишется тест, покрывающий желаемое изменение, затем пишется программный код, который реализует желаемое поведение системы и позволит пройти написанный тест, а затем проводится рефакторинг написанного кода с постоянной проверкой прохождения всех тестов.

Цикл разработки по TDD
- Добавить тест для новой (еще не реализованной) функциональности или для воспроизведения существующего бага
- Запустить все тесты и убедиться, что новый тест не проходит
- Написать код, который обеспечит прохождение теста: 
- Запустить тесты и убедиться, что они все прошли успешно: прохождение нового теста подтверждает реализацию нового функционала или исправление существующей ошибки, а прохождение остальных позволяет удостовериться, что ранее реализованный функционал работает по-прежнему корректно. 
- Заняться рефакторингом и оптимизацией — улучшение сопровождаемости и быстродействия целесообразно осуществлять уже после того, как получилось добиться проверяемой работоспособности
- Перезапустить тесты и убедиться, что они все ещё проходят успешно
- Повторить цикл

