
# отличия массива от коллекции
-----------------------
Разница есть.
Массив - структура объектов фиксированного размера
Коллекция - структура объектов с динамически изменяющейся размерностью
Отсюда определяется и область применения: массивы следует применять там, где будет строго фиксированное количество элементов; если предполагается изменение количества элементов, следует применять коллекции.


# мютекс
Только один поток может получить блокировку и иметь доступ к защищаемым мьютексом синхронизированным областям кода.
```C#
            SharedRes.mtx.WaitOne();
            //somecode
            SharedRes.mtx.ReleaseMutex();
```

# семафор
Обычно поток, которому требуется доступ к общему ресурсу, пытается получить разрешение от семафора. Если значение счетчика семафора больше нуля, то поток получает разрешение, а счетчик семафора декрементируется. В противном случае поток блокируется до тех пор, пока не получит разрешение. Когда же потоку больше не требуется доступ к общему ресурсу, он высвобождает разрешение, а счетчик семафора инкрементируется. Если разрешения ожидает другой поток, то он получает его в этот момент. Количество одновременно разрешаемых доступов указывается при создании семафора. Так, если создать семафор, одновременно разрешающий только один доступ, то такой семафор будет действовать как мьютекс.

# lock

Решение проблемы состоит в том, чтобы синхронизировать потоки и ограничить доступ к разделяемым ресурсам на время их использования каким-нибудь потоком. Для этого используется ключевое слово lock. Оператор lock определяет блок кода, внутри которого весь код блокируется и становится недоступным для других потоков до завершения работы текущего потока. Остальный потоки помещаются в очередь ожидания и ждут, пока текущий поток не освободит данный блок кода. В итоге с помощью lock мы можем переделать предыдущий пример следующим образом:

```C#
int x = 0;
object locker = new();  // объект-заглушка
// запускаем пять потоков
for (int i = 1; i < 6; i++)
{
    Thread myThread = new(Print);
    myThread.Name = $"Поток {i}";
    myThread.Start();
}
 
 
void Print()
{
    lock (locker)
    {
        x = 1;
        for (int i = 1; i < 6; i++)
        {
            Console.WriteLine($"{Thread.CurrentThread.Name}: {x}");
            x++;
            Thread.Sleep(100);
        }
    }
}
```

synchronization primitives


что такое хороший юнит тест <br>
что такое 3A тест<br>
принцип FIRST<br>
TDD <br>

