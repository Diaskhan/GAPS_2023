1.Что такое сборка мусора?
Вывоз мусора
Когда программа запускается, система выделяет часть памяти для выполнения программы.

Когда программа C# создает экземпляр класса, она создает объект.

Программа манипулирует объектом, и в какой-то момент объект может уже не понадобиться.
Когда объект больше не доступен для программы и становится кандидатом на сборку мусора.

В памяти есть два места, где CLR хранит элементы во время выполнения вашего кода.


куча стека
Стек отслеживает, что выполняется в вашем коде (например, ваши локальные переменные), а куча отслеживает ваши объекты.

Типы значений могут храниться как в стеке, так и в куче.

Для объекта в куче всегда есть ссылка в стеке, которая указывает на него.

Сборщик мусора начинает очистку только тогда, когда в куче недостаточно места для создания нового объекта.
Стек автоматически очищается в конце метода. CLR позаботится об этом, и вам не нужно об этом беспокоиться.

Куча управляется сборщиком мусора.

В неуправляемых средах без сборщика мусора вы должны отслеживать, какие объекты были выделены в куче, и вам нужно освобождать их явно. В .NET Framework это делает сборщик мусора.
 
<hr>
2.Что такое сильные и слабые ссылки в GC?
Сборщик мусора не может собрать объект, используемый приложением, пока код приложения может получить доступ к этому объекту. Говорят, что приложение имеет сильную ссылку на объект.

Слабая ссылка позволяет сборщику мусора собирать объект, в то же время разрешая приложению доступ к объекту. Слабая ссылка действительна только в течение неопределенного промежутка времени, пока объект не будет собран, когда нет сильных ссылок. При использовании слабой ссылки приложение по-прежнему может получить сильную ссылку на объект, что предотвращает его сбор. Однако всегда существует риск того, что сборщик мусора доберется до объекта раньше, чем будет восстановлена ​​сильная ссылка.

Слабые ссылки полезны для объектов, которые используют много памяти, но могут быть легко воссозданы, если они будут утилизированы сборщиком мусора.

 
<hr>

3.Как сборщик мусора узнает, что объект готов к сбору?
GC обычно собирает объекты, когда объект недоступен, т.е. не находится в ссылке.
Сборщик мусора использует следующую информацию, чтобы определить, являются ли объекты живыми:

Стек корней. Переменные стека, предоставляемые JIT-компилятором и обходчиком стека.
Ручки для сбора мусора. Обрабатывает, которые указывают на управляемые объекты и могут быть выделены пользовательским кодом или общеязыковой средой выполнения.
Статические данные. Статические объекты в доменах приложений, которые могут ссылаться на другие объекты. Каждый домен приложения отслеживает свои статические объекты.
 

<hr>

4.Что такое поколения в GC?
После того как CLR инициализирует сборщик мусора, он выделяет сегмент памяти для хранения объектов и управления ими.

Эта память называется управляемой кучей, в отличие от собственной кучи в операционной системе.

Для каждого управляемого процесса существует управляемая куча. Все потоки процесса выделяют память для объектов в одной куче.

Куча организована в виде поколений, поэтому она может обрабатывать долгоживущие и короткоживущие объекты. Сборка мусора в основном происходит при утилизации недолговечных объектов, которые обычно занимают лишь небольшую часть кучи. В куче есть три поколения объектов:

Поколение 0. Это самое молодое поколение и содержит короткоживущие объекты. Примером недолговечного объекта является временная переменная. Сбор мусора происходит чаще всего в этом поколении.

Вновь выделенные объекты образуют новое поколение объектов и неявно являются коллекциями поколения 0, если только они не являются большими объектами, и в этом случае они помещаются в кучу больших объектов в коллекции поколения 2.

Большинство объектов утилизируются для сборки мусора в поколении 0 и не сохраняются до следующего поколения.
Поколение 1. Это поколение содержит короткоживущие объекты и служит буфером между короткоживущими и долгоживущими объектами.
Поколение 2. Это поколение содержит долгоживущие объекты. Примером долгоживущего объекта является объект в серверном приложении, содержащий статические данные, действующие в течение всего процесса.

Сборка мусора происходит в определенных поколениях, если того требуют условия. Сбор поколения означает сбор объектов в этом поколении и во всех его младших поколениях. Сборка мусора поколения 2 также называется полной сборкой мусора, поскольку она утилизирует все объекты во всех поколениях (то есть все объекты в управляемой куче).

- Поколение 0 — короткоживущие объекты.
- Поколение 1 — в качестве буфера между короткоживущими и долгоживущими объектами.
- Поколение 2 — долгоживущие объекты.

 

<hr>

5.Как собираются типы значений по сравнению с ссылочными типами?
Типы значений сохраняются в стеке, и поэтому они удаляются из стека методом pop, когда приложение завершает их использование.

Ссылочные типы хранятся в куче, поэтому их собирает сборщик мусора.
 

<hr>
6.Утилизировать против финализации
Утилизировать	Завершить
Он используется для освобождения неуправляемых ресурсов в любое время.	Его можно использовать для освобождения неуправляемых ресурсов, удерживаемых объектом, до того, как этот объект будет уничтожен.
Он вызывается кодом пользователя, и класс, реализующий метод dispose, должен реализовать интерфейс IDisposable.	Он вызывается сборщиком мусора и не может быть вызван кодом пользователя.
Это реализовано путем реализации метода Dispose() интерфейса IDisposable.	Реализовано с помощью деструкторов
Метод Dispose не требует затрат на производительность.	С методом Finalize связаны затраты на производительность, поскольку он не очищает память немедленно и автоматически вызывается сборщиком мусора.
 

<hr>
7.Можем ли мы закрепить объекты для последующих ссылок?
CLR позволяет нам «закрепить» объект, чтобы он не перемещался во время сборки мусора. Однако потенциально это может иметь серьезные последствия для сборки мусора; куча по-прежнему фрагментирована, если объект закреплен во время прохода. Более того, если объект становится пригодным для сжатия после прохода, он по-прежнему считается объектом поколения 0, даже если он должен был быть перемещен в поколение 1. C# позволяет нам закрепить объект с помощью оператора fixed.

Оператор fixed запрещает сборщику мусора перемещать подвижную переменную. Оператор fixed разрешен только в небезопасном контексте.
 

<hr>
8. Работает ли GC аналогично для веб-приложения и приложения Windows? Есть ли разница?
Сборщик мусора работает в «режиме рабочей станции» для приложения Windows, который может быть параллельным или непараллельным. Параллельная сборка мусора позволяет управляемым потокам продолжать операции во время сборки мусора.

Начиная с .NET Framework 4, фоновая сборка мусора заменяет параллельную сборку мусора.

А для веб-приложения работает в режиме «Сборка мусора на сервере», который предназначен для серверных приложений, которым требуется высокая пропускная способность и масштабируемость. Сборка мусора сервера может быть непараллельной или фоновой.
 

<hr>
9. Как форсировать сборку мусора?
Вы можете принудительно сделать это, добавив вызов GC.Collect.
 

Пример
Поток StreamWriter = File.CreateText("temp.dat");
stream.Write("некоторые тестовые данные");
GC.Собрать();
GC.WaitForPendingFinalizers();
Файл.Удалить («temp.dat»);

 
<hr>
10. Почему сборка мусора очищает только кучу?
Сборщик мусора сканирует стек, чтобы увидеть, какие элементы в куче в настоящее время используются (на что указывают) объекты в стеке.

Сборщику мусора не имеет смысла собирать память стека, потому что стек не управляется таким образом: все в стеке считается «используемым». И память, используемая стеком, автоматически освобождается, когда вы возвращаетесь из вызовов метода. Управление памятью пространства стека настолько простое, дешевое и легкое, что вам не захочется использовать сборку мусора.
 

Вы можете прочитать несколько других аспектов сборки мусора здесь .